---
title: FastAPI
description: Framework web moderne et rapide pour construire des APIs avec Python
navigation:
  icon: i-logos-fastapi-icon
seo:
  title: FastAPI - Guide complet
  description: Guide complet pour développer des APIs avec FastAPI
---

::note
Documentation officielle
- [FastAPI](https://fastapi.tiangolo.com/)
- [Pydantic](https://docs.pydantic.dev/)
- [Uvicorn](https://www.uvicorn.org/)
::

## Prérequis

```shell
# Créer un environnement de développement
python3 -m venv venv

# Activer l'environnement virtuel
source venv/bin/activate

# Installer FastAPI et Uvicorn
pip install "fastapi[all]"
```

::note
Désactiver l'environnement virtuel
```shell 
deactivate
```
::

## Démarrage rapide

### Créer le fichier `main.py`

```python [main.py]
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```

### Démarrer le serveur

```shell
uvicorn main:app --reload
```

::tip
**Accès à la documentation**
- Swagger UI : `http://localhost:8000/docs`
- ReDoc : `http://localhost:8000/redoc`
::

## Routes et méthodes HTTP

### Routes basiques

```python [main.py]
from fastapi import FastAPI

app = FastAPI()

@app.get("/items")
async def get_items():
    return {"items": ["item1", "item2"]}

@app.post("/items")
async def create_item(name: str):
    return {"name": name, "id": 1}

@app.put("/items/{item_id}")
async def update_item(item_id: int, name: str):
    return {"id": item_id, "name": name}

@app.delete("/items/{item_id}")
async def delete_item(item_id: int):
    return {"message": f"Item {item_id} deleted"}
```

### Paramètres de chemin

```python
@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}

@app.get("/users/{user_id}/items/{item_id}")
async def read_user_item(user_id: int, item_id: str):
    return {"user_id": user_id, "item_id": item_id}
```

### Paramètres de requête

```python
@app.get("/items")
async def read_items(skip: int = 0, limit: int = 10):
    return {"skip": skip, "limit": limit}

# Paramètres optionnels
@app.get("/items/{item_id}")
async def read_item(item_id: str, q: str | None = None):
    if q:
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id}
```

## Modèles Pydantic

### Définir des modèles

```python [models.py]
from pydantic import BaseModel, Field, EmailStr
from datetime import datetime

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: str | None = Field(None, max_length=500)
    price: float = Field(..., gt=0)
    tax: float | None = None
    tags: list[str] = []

class User(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
    disabled: bool = False
    
    class Config:
        json_schema_extra = {
            "example": {
                "username": "johndoe",
                "email": "john@example.com",
                "full_name": "John Doe"
            }
        }
```

### Utiliser les modèles

```python [main.py]
from fastapi import FastAPI
from models import Item, User

app = FastAPI()

@app.post("/items")
async def create_item(item: Item):
    item_dict = item.model_dump()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.model_dump()}
```

## Gestion des erreurs

```python [main.py]
from fastapi import FastAPI, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

items_db = {"foo": {"name": "Foo", "price": 50.2}}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )
    return items_db[item_id]

# Gestionnaire d'erreurs personnalisé
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()}
    )
```

## Dépendances

```python [dependencies.py]
from fastapi import Header, HTTPException

async def verify_token(x_token: str = Header()):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="Invalid token")

async def verify_key(x_key: str = Header()):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="Invalid key")
    return x_key
```

```python [main.py]
from fastapi import FastAPI, Depends
from dependencies import verify_token, verify_key

app = FastAPI()

@app.get("/items", dependencies=[Depends(verify_token)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

@app.get("/users")
async def read_users(key: str = Depends(verify_key)):
    return [{"username": "Rick"}, {"username": "Morty"}]
```

## Base de données

### Configuration SQLAlchemy

```python [database.py]
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### Modèles SQLAlchemy

```python [models.py]
from sqlalchemy import Boolean, Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
```

### Utilisation

```python [main.py]
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from database import get_db
import models

app = FastAPI()

@app.post("/users")
def create_user(username: str, email: str, db: Session = Depends(get_db)):
    db_user = models.User(username=username, email=email)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get("/users/{user_id}")
def read_user(user_id: int, db: Session = Depends(get_db)):
    return db.query(models.User).filter(models.User.id == user_id).first()
```

## Middleware

```python [main.py]
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import time

app = FastAPI()

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middleware personnalisé
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

## Tests

```python [test_main.py]
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_create_item():
    response = client.post(
        "/items",
        json={"name": "Test", "price": 10.5}
    )
    assert response.status_code == 200
    assert response.json()["name"] == "Test"
```

```shell
# Installer pytest
pip install pytest

# Lancer les tests
pytest
```

## Gestion des dépendances

::tip
**Fichier requirements.txt**
```shell
# Générer le fichier
pip freeze > requirements.txt

# Installer depuis le fichier
pip install -r requirements.txt
```
::

```text [requirements.txt]
fastapi[all]==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.0
sqlalchemy==2.0.25
pytest==7.4.4
```

## Automatiser le démarrage

### Script de démarrage

```shell [start.sh]
#!/bin/bash

# Activer l'environnement virtuel
source venv/bin/activate

# Démarrer le serveur
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

```shell
# Rendre le script exécutable
chmod +x start.sh

# Lancer le projet
./start.sh
```

## Déploiement

### Docker

```dockerfile [Dockerfile]
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml [docker-compose.yml]
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/dbname
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=dbname
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### Production avec Gunicorn

```shell
# Installer Gunicorn
pip install gunicorn

# Démarrer avec Gunicorn
gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

## Bonnes pratiques

::list{type="success"}
- Utiliser des modèles Pydantic pour la validation
- Documenter les endpoints avec des descriptions
- Implémenter une gestion d'erreurs cohérente
- Utiliser des dépendances pour le code réutilisable
- Écrire des tests pour chaque endpoint
- Versionner l'API (`/api/v1/...`)
- Configurer CORS correctement
- Utiliser des variables d'environnement pour la configuration
::

## Ressources

::list{type="info"}
- [Documentation FastAPI](https://fastapi.tiangolo.com/)
- [Tutoriel complet](https://fastapi.tiangolo.com/tutorial/)
- [Pydantic](https://docs.pydantic.dev/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [Awesome FastAPI](https://github.com/mjhea0/awesome-fastapi)
::

---
title: Vue 3
description: Texte, titres et mise en forme en markdown standard.
navigation:
  icon: i-logos-vue
---

Vue, prononcé comme en anglais (/vjuː/), est un framework JavaScript qui s'appuie sur les normes de HTML, CSS et JavaScript. Il offre une approche efficace pour la création d'interfaces utilisateur, que celles-ci soient simples ou complexes, en permettant une déclaration claire de composants.

## Installer Vue 3

Cette commande nous permet d'installer la dernière version de Vue JS.
```bash title="Installer Vue"
npm create vue@latest
```

## Composition API

La Composition API est une nouvelle façon d'organiser et de réutiliser le code dans les composants Vue. Elle permet de regrouper la logique liée à une fonctionnalité spécifique, facilitant ainsi la maintenance et la réutilisation du code.

### Script Setup

```vue
<script setup lang="ts">
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)

function increment() {
  count.value++
}
</script>
```

## Règles de Syntaxe et Conventions

### Nommage des Composants

```vue
<!-- ✅ Bon : PascalCase pour les composants -->
<MyComponent />
<UserProfile />

<!-- ❌ Éviter : kebab-case dans les templates SFC -->
<my-component />
```

### Props et Events

```vue
<script setup lang="ts">
// Props : camelCase dans le script
defineProps<{
  userId: number
  isActive: boolean
}>()

// Events : kebab-case recommandé
const emit = defineEmits<{
  'update:value': [value: string]
  'user-selected': [id: number]
}>()
</script>

<template>
  <!-- kebab-case dans le template -->
  <ChildComponent 
    :user-id="userId"
    :is-active="isActive"
    @update:value="handleUpdate"
    @user-selected="onUserSelected"
  />
</template>
```

### Ordre des Options du Composant

```vue
<script setup lang="ts">
// 1. Imports
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'

// 2. Props
const props = defineProps<{ id: string }>()

// 3. Emits
const emit = defineEmits<{ submit: [data: FormData] }>()

// 4. Composables
const router = useRouter()

// 5. State (ref, reactive)
const data = ref<Data | null>(null)

// 6. Computed
const isValid = computed(() => data.value !== null)

// 7. Methods
function handleSubmit() {
  // ...
}

// 8. Lifecycle hooks
onMounted(() => {
  // ...
})
</script>
```

## Composables

Les composables sont des fonctions réutilisables qui encapsulent la logique stateful en utilisant la Composition API.

### Structure d'un Composable

```typescript
// composables/useCounter.ts
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  const doubleCount = computed(() => count.value * 2)

  function increment() {
    count.value++
  }

  function decrement() {
    count.value--
  }

  function reset() {
    count.value = initialValue
  }

  return {
    count: readonly(count),
    doubleCount,
    increment,
    decrement,
    reset
  }
}
```

### Composable Fetch avec Gestion d'État

```typescript
// composables/useFetch.ts
import { ref, type Ref } from 'vue'

interface UseFetchOptions {
  immediate?: boolean
}

export function useFetch<T>(url: Ref<string> | string, options: UseFetchOptions = {}) {
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const loading = ref(false)

  async function fetch() {
    loading.value = true
    error.value = null

    try {
      const response = await window.fetch(unref(url))
      if (!response.ok) throw new Error(response.statusText)
      data.value = await response.json()
    } catch (e) {
      error.value = e as Error
    } finally {
      loading.value = false
    }
  }

  if (options.immediate !== false) {
    fetch()
  }

  return { data, error, loading, refetch: fetch }
}
```

### Utilisation

```vue
<script setup lang="ts">
import { useFetch } from '@/composables/useFetch'

interface User {
  id: number
  name: string
}

const { data: user, error, loading } = useFetch<User>('/api/user/1')
</script>
```

## TypeScript avec Vue 3

### Typage des Props

```vue
<script setup lang="ts">
interface Props {
  title: string
  count?: number
  tags: string[]
  user: {
    id: number
    name: string
  }
}

// Avec valeurs par défaut
const props = withDefaults(defineProps<Props>(), {
  count: 0
})
</script>
```

### Typage des Refs et Reactive

```typescript
import { ref, reactive } from 'vue'

// Ref avec type explicite
const count = ref<number>(0)
const user = ref<User | null>(null)

// Reactive avec interface
interface State {
  loading: boolean
  data: User[]
}

const state = reactive<State>({
  loading: false,
  data: []
})
```

### Typage des Template Refs

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'

const inputRef = ref<HTMLInputElement | null>(null)

onMounted(() => {
  inputRef.value?.focus()
})
</script>

<template>
  <input ref="inputRef" type="text" />
</template>
```

## Vue Router

### Installation et Configuration

```bash
npm install vue-router@4
```

```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'home',
    component: () => import('@/views/HomeView.vue')
  },
  {
    path: '/users/:id',
    name: 'user-detail',
    component: () => import('@/views/UserDetail.vue'),
    props: true
  },
  {
    path: '/admin',
    component: () => import('@/layouts/AdminLayout.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: 'dashboard',
        name: 'admin-dashboard',
        component: () => import('@/views/admin/Dashboard.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})

// Navigation Guard
router.beforeEach((to, from, next) => {
  if (to.meta.requiresAuth && !isAuthenticated()) {
    next({ name: 'login' })
  } else {
    next()
  }
})

export default router
```

### Utilisation dans les Composants

```vue
<script setup lang="ts">
import { useRouter, useRoute } from 'vue-router'

const router = useRouter()
const route = useRoute()

// Accéder aux paramètres
const userId = route.params.id

// Navigation programmatique
function goToUser(id: number) {
  router.push({ name: 'user-detail', params: { id } })
}

// Navigation avec query
function search(term: string) {
  router.push({ 
    name: 'search', 
    query: { q: term } 
  })
}
</script>

<template>
  <RouterLink :to="{ name: 'home' }">Accueil</RouterLink>
  <RouterLink :to="`/users/${userId}`">Profil</RouterLink>
</template>
```

### Composable Router Personnalisé

```typescript
// composables/useRouterHelper.ts
import { useRouter } from 'vue-router'

export function useRouterHelper() {
  const router = useRouter()

  function goBack() {
    router.back()
  }

  function navigateWithConfirmation(to: string, message: string) {
    if (confirm(message)) {
      router.push(to)
    }
  }

  return {
    goBack,
    navigateWithConfirmation
  }
}
```

## Pinia - State Management

### Installation

```bash
npm install pinia
```

```typescript
// main.ts
import { createPinia } from 'pinia'

const app = createApp(App)
app.use(createPinia())
```

### Création d'un Store

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useUserStore = defineStore('user', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref<string | null>(localStorage.getItem('token'))

  // Getters
  const isAuthenticated = computed(() => !!token.value)
  const userName = computed(() => user.value?.name ?? 'Invité')

  // Actions
  async function login(email: string, password: string) {
    try {
      const response = await api.post('/auth/login', { email, password })
      token.value = response.data.token
      user.value = response.data.user
      localStorage.setItem('token', token.value)
    } catch (error) {
      throw new Error('Échec de connexion')
    }
  }

  function logout() {
    user.value = null
    token.value = null
    localStorage.removeItem('token')
  }

  return {
    // State
    user,
    token,
    // Getters
    isAuthenticated,
    userName,
    // Actions
    login,
    logout
  }
})
```

### Store avec Options API

```typescript
// stores/counter.ts
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
    history: [] as number[]
  }),

  getters: {
    doubleCount: (state) => state.count * 2,
    lastValue: (state) => state.history[state.history.length - 1]
  },

  actions: {
    increment() {
      this.history.push(this.count)
      this.count++
    },

    async incrementAsync() {
      await new Promise(resolve => setTimeout(resolve, 1000))
      this.increment()
    }
  }
})
```

### Utilisation dans les Composants

```vue
<script setup lang="ts">
import { useUserStore } from '@/stores/user'
import { storeToRefs } from 'pinia'

const userStore = useUserStore()

// ✅ Bon : utiliser storeToRefs pour garder la réactivité
const { user, isAuthenticated } = storeToRefs(userStore)

// ✅ Les actions peuvent être destructurées directement
const { login, logout } = userStore

async function handleLogin() {
  await login('user@example.com', 'password')
}
</script>
```

## Axios - Requêtes HTTP

### Installation et Configuration

```bash
npm install axios
```

```typescript
// services/api.ts
import axios, { type AxiosInstance } from 'axios'
import { useUserStore } from '@/stores/user'

const api: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Intercepteur de requête
api.interceptors.request.use(
  (config) => {
    const userStore = useUserStore()
    if (userStore.token) {
      config.headers.Authorization = `Bearer ${userStore.token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Intercepteur de réponse
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      const userStore = useUserStore()
      userStore.logout()
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default api
```

### Service API Typé

```typescript
// services/userService.ts
import api from './api'

export interface User {
  id: number
  name: string
  email: string
}

export interface CreateUserDto {
  name: string
  email: string
  password: string
}

export const userService = {
  async getAll(): Promise<User[]> {
    const { data } = await api.get<User[]>('/users')
    return data
  },

  async getById(id: number): Promise<User> {
    const { data } = await api.get<User>(`/users/${id}`)
    return data
  },

  async create(user: CreateUserDto): Promise<User> {
    const { data } = await api.post<User>('/users', user)
    return data
  },

  async update(id: number, user: Partial<User>): Promise<User> {
    const { data } = await api.patch<User>(`/users/${id}`, user)
    return data
  },

  async delete(id: number): Promise<void> {
    await api.delete(`/users/${id}`)
  }
}
```

### Composable avec Axios

```typescript
// composables/useApi.ts
import { ref } from 'vue'
import type { AxiosError } from 'axios'

export function useApi<T>() {
  const data = ref<T | null>(null)
  const error = ref<string | null>(null)
  const loading = ref(false)

  async function execute(apiCall: () => Promise<T>) {
    loading.value = true
    error.value = null

    try {
      data.value = await apiCall()
    } catch (e) {
      const axiosError = e as AxiosError
      error.value = axiosError.response?.data?.message || 'Une erreur est survenue'
    } finally {
      loading.value = false
    }
  }

  return { data, error, loading, execute }
}
```

### Utilisation

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import { useApi } from '@/composables/useApi'
import { userService, type User } from '@/services/userService'

const { data: users, error, loading, execute } = useApi<User[]>()

onMounted(() => {
  execute(() => userService.getAll())
})

async function deleteUser(id: number) {
  await execute(() => userService.delete(id))
  // Recharger la liste
  execute(() => userService.getAll())
}
</script>

<template>
  <div v-if="loading">Chargement...</div>
  <div v-else-if="error">{{ error }}</div>
  <ul v-else>
    <li v-for="user in users" :key="user.id">
      {{ user.name }}
      <button @click="deleteUser(user.id)">Supprimer</button>
    </li>
  </ul>
</template>
```

## Structure de Projet Recommandée

```
src/
├── assets/          # Images, fonts, styles globaux
├── components/      # Composants réutilisables
│   ├── ui/         # Composants UI de base (Button, Input, etc.)
│   └── features/   # Composants métier
├── composables/     # Fonctions composables réutilisables
├── layouts/         # Layouts de page
├── router/          # Configuration du routeur
├── services/        # Services API
├── stores/          # Stores Pinia
├── types/           # Types TypeScript partagés
├── utils/           # Fonctions utilitaires
├── views/           # Pages/Vues
├── App.vue
└── main.ts
```

## Bonnes Pratiques Générales

### 1. Utiliser `<script setup>` avec TypeScript

```vue
<script setup lang="ts">
// Code plus concis et performant
</script>
```

### 2. Props avec valeurs par défaut

```typescript
const props = withDefaults(defineProps<Props>(), {
  size: 'medium',
  disabled: false
})
```

### 3. Éviter les mutations directes des props

```vue
<script setup lang="ts">
// ❌ Mauvais
const props = defineProps<{ count: number }>()
props.count++ // Ne pas faire

// ✅ Bon : utiliser un ref local
const localCount = ref(props.count)
</script>
```

### 4. Utiliser `defineExpose` avec parcimonie

```vue
<script setup lang="ts">
function focus() {
  // ...
}

// Exposer uniquement ce qui est nécessaire
defineExpose({ focus })
</script>
```

### 5. Lazy Loading des composants

```typescript
// Composants lourds ou conditionnels
const HeavyComponent = defineAsyncComponent(
  () => import('@/components/HeavyComponent.vue')
)
```


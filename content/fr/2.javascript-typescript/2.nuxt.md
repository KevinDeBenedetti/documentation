---
title: Nuxt
description: Texte, titres et mise en forme en markdown standard.
navigation:
  icon: i-devicon:nuxt
---

Nuxt est un framework web open-source basé sur Vue.js qui permet de créer des applications web performantes et optimisées pour le SEO. Il offre un rendu côté serveur (SSR), une génération de sites statiques (SSG) et bien plus encore.

## Pourquoi Choisir Nuxt Plutôt que Vue ?

### Quand Utiliser Nuxt

✅ **Utilisez Nuxt si vous avez besoin de :**

- **SEO optimisé** : Sites vitrines, blogs, e-commerce, sites marketing
- **Performance** : Temps de chargement initial rapide avec SSR ou SSG
- **Routing automatique** : Système de fichiers basé sur les pages
- **Server-Side Rendering** : Contenu pré-rendu côté serveur
- **Static Site Generation** : Sites entièrement statiques et ultra-rapides
- **API Routes** : Backend intégré directement dans votre projet
- **Configuration zero** : Beaucoup de fonctionnalités prêtes à l'emploi

### Quand Utiliser Vue Seul

✅ **Utilisez Vue si vous créez :**

- **SPA (Single Page Application)** : Dashboards, applications internes
- **Applications nécessitant une flexibilité totale** : Configuration personnalisée
- **Projets avec des besoins spécifiques** : Architecture sur-mesure
- **Applications ne nécessitant pas de SEO** : Outils internes, back-office
- **Prototypes rapides** : Projets simples sans infrastructure complexe

### Comparaison Vue vs Nuxt

| Critère                  | Vue                 | Nuxt                          |
| ------------------------ | ------------------- | ----------------------------- |
| **Routing**              | Manuel (Vue Router) | Automatique (file-based)      |
| **SEO**                  | Limité (CSR)        | Excellent (SSR/SSG)           |
| **Performance initiale** | Plus lente (CSR)    | Plus rapide (SSR/SSG)         |
| **Configuration**        | Manuelle            | Convention over configuration |
| **Backend**              | Séparé              | API routes intégrées          |
| **Complexité**           | Plus simple         | Plus de concepts              |
| **Déploiement**          | SPA classique       | Nécessite Node.js ou static   |

## Installation de Nuxt 3

```bash
npx nuxi@latest init my-app
cd my-app
npm install
npm run dev
```

## Routing Automatique

### Pages et Routes

Nuxt génère automatiquement les routes basées sur la structure du dossier `pages/`.

```
pages/
├── index.vue           → /
├── about.vue           → /about
├── users/
│   ├── index.vue      → /users
│   ├── [id].vue       → /users/:id
│   └── profile.vue    → /users/profile
└── blog/
    └── [slug].vue     → /blog/:slug
```

### Page Dynamique

```vue
<!-- filepath: pages/users/[id].vue -->
<script setup lang="ts">
const route = useRoute()
const userId = route.params.id

const { data: user } = await useFetch(`/api/users/${userId}`)
</script>

<template>
  <div>
    <h1>Profil de {{ user?.name }}</h1>
  </div>
</template>
```

### Route avec Query Parameters

```vue
<!-- filepath: pages/search.vue -->
<script setup lang="ts">
const route = useRoute()
const query = computed(() => route.query.q as string)

// Watcher sur les changements de query
watch(query, (newQuery) => {
  console.log('Nouvelle recherche:', newQuery)
})
</script>
```

### Catch-all Route

```vue
<!-- filepath: pages/[...slug].vue -->
<script setup lang="ts">
const route = useRoute()
const slug = route.params.slug // ['path', 'to', 'page']
</script>
```

## Navigation

### NuxtLink

```vue
<template>
  <!-- Navigation simple -->
  <NuxtLink to="/about">À propos</NuxtLink>
  
  <!-- Navigation avec paramètres -->
  <NuxtLink :to="`/users/${user.id}`">Profil</NuxtLink>
  
  <!-- Navigation avec objet -->
  <NuxtLink :to="{ name: 'users-id', params: { id: 1 } }">
    Utilisateur 1
  </NuxtLink>
  
  <!-- Navigation externe -->
  <NuxtLink to="https://example.com" external>
    Site externe
  </NuxtLink>
  
  <!-- Préchargement désactivé -->
  <NuxtLink to="/heavy-page" :prefetch="false">
    Page lourde
  </NuxtLink>
</template>
```

### Navigation Programmatique

```vue
<script setup lang="ts">
const router = useRouter()

function goToUser(id: number) {
  router.push(`/users/${id}`)
}

function goBack() {
  router.back()
}

async function navigateWithRedirect() {
  // Redirection côté serveur
  await navigateTo('/dashboard', { redirectCode: 301 })
}
</script>
```

## Layouts

### Layout par Défaut

```vue
<!-- filepath: layouts/default.vue -->
<template>
  <div>
    <header>
      <nav>
        <NuxtLink to="/">Accueil</NuxtLink>
        <NuxtLink to="/about">À propos</NuxtLink>
      </nav>
    </header>
    
    <main>
      <slot />
    </main>
    
    <footer>
      <p>&copy; 2024 Mon Site</p>
    </footer>
  </div>
</template>
```

### Layout Personnalisé

```vue
<!-- filepath: layouts/admin.vue -->
<template>
  <div class="admin-layout">
    <aside class="sidebar">
      <!-- Sidebar admin -->
    </aside>
    <main>
      <slot />
    </main>
  </div>
</template>
```

### Utilisation dans les Pages

```vue
<!-- filepath: pages/admin/dashboard.vue -->
<script setup lang="ts">
definePageMeta({
  layout: 'admin',
  middleware: 'auth'
})
</script>

<template>
  <div>
    <h1>Dashboard Admin</h1>
  </div>
</template>
```

## Composables Nuxt

### useFetch - Récupération de Données

```vue
<script setup lang="ts">
interface User {
  id: number
  name: string
  email: string
}

// Récupération simple
const { data: users, pending, error, refresh } = await useFetch<User[]>('/api/users')

// Avec options
const { data: user } = await useFetch<User>(`/api/users/${route.params.id}`, {
  key: `user-${route.params.id}`, // Cache key unique
  lazy: true, // Ne bloque pas la navigation
  server: true, // Exécuté côté serveur
  watch: [() => route.params.id], // Re-fetch quand l'ID change
  transform: (data) => {
    // Transformer les données
    return { ...data, fullName: `${data.name}` }
  },
  onRequest({ request, options }) {
    // Intercepteur avant la requête
  },
  onResponse({ response }) {
    // Intercepteur après la réponse
  }
})
</script>

<template>
  <div v-if="pending">Chargement...</div>
  <div v-else-if="error">Erreur : {{ error.message }}</div>
  <div v-else>
    <div v-for="user in users" :key="user.id">
      {{ user.name }}
    </div>
    <button @click="refresh()">Actualiser</button>
  </div>
</template>
```

### useAsyncData - Récupération Personnalisée

```vue
<script setup lang="ts">
// Pour des requêtes complexes ou non-HTTP
const { data, pending } = await useAsyncData(
  'custom-data',
  async () => {
    // Logique personnalisée
    const response = await $fetch('/api/data')
    const processed = processData(response)
    return processed
  },
  {
    lazy: true,
    server: false // Uniquement côté client
  }
)
</script>
```

### useState - État Partagé

```typescript
// composables/useCounter.ts
export const useCounter = () => {
  // État partagé entre tous les composants
  const count = useState('counter', () => 0)
  
  function increment() {
    count.value++
  }
  
  return { count, increment }
}
```

```vue
<!-- Utilisation dans n'importe quel composant -->
<script setup lang="ts">
const { count, increment } = useCounter()
// Le même état est partagé partout
</script>
```

### useHead - Meta Tags

```vue
<script setup lang="ts">
useHead({
  title: 'Mon Titre de Page',
  meta: [
    { name: 'description', content: 'Description de ma page' },
    { property: 'og:title', content: 'Titre Open Graph' },
    { property: 'og:image', content: '/image.jpg' }
  ],
  link: [
    { rel: 'canonical', href: 'https://monsite.com/page' }
  ]
})

// Dynamique
const { data: article } = await useFetch('/api/article/1')

useHead({
  title: () => article.value?.title,
  meta: [
    { name: 'description', content: () => article.value?.description }
  ]
})
</script>
```

### useCookie - Gestion des Cookies

```typescript
export const useAuth = () => {
  const token = useCookie('auth-token', {
    maxAge: 60 * 60 * 24 * 7, // 7 jours
    secure: true,
    httpOnly: true,
    sameSite: 'strict'
  })
  
  function setToken(newToken: string) {
    token.value = newToken
  }
  
  function clearToken() {
    token.value = null
  }
  
  return { token, setToken, clearToken }
}
```

## Middleware

### Middleware de Route

```typescript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { token } = useAuth()
  
  if (!token.value) {
    return navigateTo('/login')
  }
})
```

```vue
<!-- Utilisation dans une page -->
<script setup lang="ts">
definePageMeta({
  middleware: 'auth'
})
</script>
```

### Middleware Global

```typescript
// middleware/analytics.global.ts
export default defineNuxtRouteMiddleware((to, from) => {
  // Exécuté sur chaque navigation
  console.log('Navigation vers:', to.path)
})
```

### Middleware Inline

```vue
<script setup lang="ts">
definePageMeta({
  middleware: [
    'auth',
    function (to, from) {
      // Middleware inline
      if (!hasPermission()) {
        return abortNavigation('Accès refusé')
      }
    }
  ]
})
</script>
```

## Server API Routes

### Route API Simple

```typescript
// server/api/hello.ts
export default defineEventHandler((event) => {
  return {
    message: 'Hello World!'
  }
})
```

### Route avec Paramètres

```typescript
// server/api/users/[id].ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  
  // Récupérer l'utilisateur
  const user = await prisma.user.findUnique({
    where: { id: parseInt(id!) }
  })
  
  if (!user) {
    throw createError({
      statusCode: 404,
      message: 'Utilisateur non trouvé'
    })
  }
  
  return user
})
```

### Route POST avec Validation

```typescript
// server/api/users/index.post.ts
import { z } from 'zod'

const createUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(8)
})

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  
  // Validation
  const validatedData = createUserSchema.parse(body)
  
  // Créer l'utilisateur
  const user = await prisma.user.create({
    data: validatedData
  })
  
  return user
})
```

### Middleware Serveur

```typescript
// server/middleware/auth.ts
export default defineEventHandler(async (event) => {
  const token = getCookie(event, 'auth-token')
  
  if (event.path.startsWith('/api/admin') && !token) {
    throw createError({
      statusCode: 401,
      message: 'Non authentifié'
    })
  }
})
```

## Plugins

### Plugin Simple

```typescript
// plugins/my-plugin.ts
export default defineNuxtPlugin((nuxtApp) => {
  // Injection globale
  return {
    provide: {
      hello: (name: string) => `Hello ${name}!`
    }
  }
})
```

```vue
<!-- Utilisation -->
<script setup lang="ts">
const { $hello } = useNuxtApp()
console.log($hello('World')) // "Hello World!"
</script>
```

### Plugin avec Dépendance

```typescript
// plugins/axios.ts
import axios from 'axios'

export default defineNuxtPlugin((nuxtApp) => {
  const api = axios.create({
    baseURL: '/api'
  })
  
  // Intercepteur
  api.interceptors.request.use((config) => {
    const token = useCookie('auth-token')
    if (token.value) {
      config.headers.Authorization = `Bearer ${token.value}`
    }
    return config
  })
  
  return {
    provide: {
      api
    }
  }
})
```

## Configuration Nuxt

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // Mode de rendu
  ssr: true, // ou false pour SPA mode
  
  // Métadonnées globales
  app: {
    head: {
      title: 'Mon Application',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' }
      ]
    }
  },
  
  // Variables d'environnement publiques
  runtimeConfig: {
    // Privé (serveur uniquement)
    apiSecret: process.env.API_SECRET,
    
    // Public (client + serveur)
    public: {
      apiBase: process.env.API_BASE_URL || 'http://localhost:3000'
    }
  },
  
  // Auto-import
  imports: {
    dirs: ['composables/**', 'utils/**']
  },
  
  // TypeScript
  typescript: {
    strict: true,
    typeCheck: true
  },
  
  // Modules
  modules: [
    '@nuxt/content',
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt'
  ],
  
  // Routage
  router: {
    options: {
      strict: true
    }
  },
  
  // Optimisation
  nitro: {
    compressPublicAssets: true,
    prerender: {
      crawlLinks: true,
      routes: ['/sitemap.xml']
    }
  }
})
```

## Bonnes Pratiques Nuxt

### 1. Utiliser useFetch au lieu de $fetch pour les Données de Page

```vue
<script setup lang="ts">
// ✅ Bon : SSR-friendly, mise en cache automatique
const { data } = await useFetch('/api/data')

// ❌ Éviter dans setup : pas de cache, pas de SSR
const data = await $fetch('/api/data')
</script>
```

### 2. Utiliser les Keys pour le Cache

```vue
<script setup lang="ts">
const route = useRoute()

// ✅ Bon : cache unique par ID
const { data } = await useFetch(`/api/users/${route.params.id}`, {
  key: `user-${route.params.id}`
})

// ❌ Sans key, le cache peut être partagé incorrectement
</script>
```

### 3. Préférer les Composables Natifs

```typescript
// ✅ Bon : utilise les composables Nuxt
export const useUser = () => {
  const user = useState('user', () => null)
  
  async function fetchUser() {
    const { data } = await useFetch('/api/user')
    user.value = data.value
  }
  
  return { user, fetchUser }
}

// ❌ Éviter : state manuel sans SSR
import { ref } from 'vue'
export const useUser = () => {
  const user = ref(null) // Pas partagé entre serveur/client
  return { user }
}
```

### 4. Optimiser les Images

```vue
<template>
  <!-- ✅ Utiliser NuxtImg pour l'optimisation -->
  <NuxtImg 
    src="/image.jpg" 
    width="300" 
    height="200" 
    loading="lazy"
    format="webp"
  />
  
  <!-- ❌ Image non optimisée -->
  <img src="/image.jpg" alt="" />
</template>
```

### 5. Gérer les Erreurs Proprement

```vue
<script setup lang="ts">
const { data, error } = await useFetch('/api/data')

if (error.value) {
  throw createError({
    statusCode: error.value.statusCode,
    message: 'Impossible de charger les données',
    fatal: true // Affiche la page d'erreur
  })
}
</script>
```

### 6. Utiliser les Pages d'Erreur Personnalisées

```vue
<!-- filepath: error.vue -->
<script setup lang="ts">
const props = defineProps<{
  error: {
    statusCode: number
    message: string
  }
}>()

function handleError() {
  clearError({ redirect: '/' })
}
</script>

<template>
  <div>
    <h1>{{ error.statusCode }}</h1>
    <p>{{ error.message }}</p>
    <button @click="handleError">Retour à l'accueil</button>
  </div>
</template>
```

## Modules SEO

::info
[Nuxt Module](https://nuxt.com/modules/seo)<br>
[SEO](https://nuxtseo.com/)
::

:::card-group

  ::card
  ---
  title: '@nuxtjs/sitemap'
  icon: i-simple-icons-github
  to: https://github.com/nuxt-modules/sitemap
  target: _blank
  ---
  Automatically generates an XML sitemap to help search engines index your pages.
  ::

  ::card
  ---
  title: '@nuxtjs/robots'
  icon: i-simple-icons-github
  to: https://github.com/nuxt-modules/robots
  target: _blank
  ---
  Creates a robots.txt file to manage crawler access.
  ::

  ::card
  ---
  title: nuxt-schema-org
  icon: i-simple-icons-github
  to: https://github.com/harlan-zw/nuxt-schema-org
  target: _blank
  ---
  Easily integrates JSON-LD schema tags to enhance search results.
  ::

  ::card
  ---
  title: nuxt-seo-experiments
  icon: i-simple-icons-github
  to: https://github.com/harlan-zw/nuxt-seo
  target: _blank
  ---
  Allows you to experiment with various SEO optimizations.
  ::

  ::card
  ---
  title: nuxt-og-image
  icon: i-simple-icons-github
  to: https://github.com/nuxt-modules/og-image
  target: _blank
  ---
  Generates images for social media previews.
  ::

  ::card
  ---
  title: nuxt-link-checker
  icon: i-simple-icons-github
  to: https://github.com/harlan-zw/nuxt-link-checker
  target: _blank
  ---
  Checks link validity to avoid 404 errors.
  ::

:::

### Installation des Modules SEO

```bash
npx nuxi@latest module add seo
```

### Configuration SEO

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/seo'],
  
  site: {
    url: 'https://monsite.com',
    name: 'Mon Site',
    description: 'Description de mon site',
    defaultLocale: 'fr'
  },
  
  sitemap: {
    strictNuxtContentPaths: true
  },
  
  robots: {
    allow: '/',
    disallow: ['/admin', '/api']
  }
})
```

## Déploiement

### Mode SSR (Serveur Node.js)

```bash
npm run build
node .output/server/index.mjs
```

### Mode Static (SSG)

```bash
npx nuxi generate
# Déployer le dossier .output/public
```

### Plateformes Recommandées

- **Vercel** : SSR et SSG, déploiement automatique
- **Netlify** : SSG principalement
- **Cloudflare Pages** : SSG et Workers pour SSR
- **Railway** : SSR avec Node.js
- **DigitalOcean** : SSR avec Docker
```
---
title: Docker
description: Guide pratique des commandes Docker et des exemples de Dockerfile pour construire.
navigation:
  icon: i-devicon:docker
seo:
  title: Docker
  description: Commandes, bonnes pratiques et exemples pour créer, exécuter et maintenir des images et conteneurs Docker.
---

## Commandes de base

### Afficher

```bash
# Afficher les conteneurs en cours d'exécution
docker ps
# Afficher les conteneurs arrêtés
docker ps -a
# Afficher les images
docker images
# Accéder au terminal d'un conteneur en cours d'exécution
docker exec -it <container_name> sh
```

### Monter

```bash
# Monter une image
docker build <image_name>
# Monter une image
docker compose up -d
```

### Sauvegarder

```bash
# Créer une sauvegarde d'un conteneur
docker save -o <save_name>.tar <image_name>
```

### Supprimer

```bash
# Un conteneur arrêté par ID
docker rm <container_id>
# Tous les conteneurs arrêtés
docker rm $(docker ps -a -q)
# Tous les conteneurs non démarrés
docker rm $(sudo docker ps -a -q -f 'status=exited')
# Image inutilisée par ID
docker rmi <image_id>
# Toutes les images inutilisées (non associées à un conteneur)
docker image prune
# Volumes inutilisés
docker prune
# Réseaux inutilisés
docker network prune
```

### Nettoyer

```bash
# Supprimer tous les objets inutilisés (conteneurs, images, volumes et réseaux)
docker system prune
# Supprimer tous les objets inutilisés, avec des conteneurs en cours d'exécution
docker system prune -a
# Nettoyage complet
docker system prune --volumes -a
```

### Exécuter

```bash
# Exécuter une image
docker run --name <container_name> <image_name>
# Exécuter une image sur un port
docker run --name <container_name> -p 3000:3000 <image_name>
```

### Charger

```bash
# Charger une image à partir d'un fichier `.tar`
docker load --input <file_name>.tar
```

## Network

Docker fournit un système de mise en réseau léger pour connecter des conteneurs entre eux et avec l'hôte. Un réseau Docker est défini par un "driver" (bridge, host, overlay, macvlan, none) et par une configuration IPAM (allocation des sous-réseaux et passerelles). Les réseaux définis par l'utilisateur (user-defined) fournissent un DNS interne permettant aux conteneurs de se résoudre par nom, ce qui facilite la communication entre services.

Principaux drivers :
- bridge : réseau par défaut pour les conteneurs d'un même hôte. Idéal pour la plupart des applications mono-hôte.
- host : supprime l'isolation réseau, le conteneur partage la pile réseau de l'hôte.
- overlay : utilisé pour la communication entre services sur plusieurs hôtes (Swarm, Kubernetes).
- macvlan : assigne des adresses MAC/IP aux conteneurs sur le réseau physique (utile pour l'intégration dans des réseaux existants).
- none : pas d'interface réseau (isolation complète).

Points importants :
- Les réseaux user-defined apportent un DNS interne et une isolation par réseau. Préférez-les au réseau bridge par défaut si vous voulez des noms explicites et une segmentation.
- Évitez d'exposer toutes les liaisons de ports quand deux conteneurs communiquent sur le même réseau : utilisez le réseau pour la communication interne et exposez seulement les ports nécessaires vers l'extérieur.
- Réserver des sous-réseaux explicites évite les conflits avec d'autres réseaux de votre infrastructure.

```bash
# Créer un réseau Docker
docker network create --subnet 172.20.0.0/16 <network_name>
# Afficher les réseaux
docker network ls
# Afficher les détails d'un réseau
docker network inspect <network_name>
# Lier un réseau à un conteneur
docker network connect --ip 172.20.0.5 <network_name> <container_name>
```

## Stack

Docker Stack permet de déployer et gérer des applications multi-conteneurs sur un cluster Docker Swarm. Une stack est définie par un fichier YAML (similaire à Docker Compose) qui décrit les services, réseaux et volumes nécessaires. Docker Stack orchestre le déploiement, la mise à l'échelle et la gestion des services sur plusieurs nœuds du cluster.

```bash
# Lister les services d'une stack
docker stack services <stack_name>
# Afficher les logs
docker service logs <stack_name_service> # `-f` pour afficher les logs en temps réel.
# Supprimer une stack
docker stack rm <stack_name>
```

## Exemples

### Dockerfile

<!-- TODO : Mettre à jour les dockerfiles -->

:::code-group

```dockerfile [Nuxt]
ARG NODE_VERSION=21.0.0

ARG PORT=3000

FROM node:${NODE_VERSION}-alpine as base

WORKDIR /app

FROM base as build

COPY package.json /app/
COPY pnpm-lock.yaml /app/

# Install pnpm
RUN npm install -g pnpm

# Install all dependencies
RUN pnpm install

ADD . /app

RUN pnpm run build

FROM base

EXPOSE $PORT

COPY --from=build /app/.output /app/.output

CMD ["node", ".output/server/index.mjs"]
```

```dockerfile [FastAPI]
FROM python:3.9

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir --upgrade -r requirements.txt

COPY . .

CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "80"]
```

:::

### Docker Compose

:::code-group

```yaml [Nuxt]
volumes:
  node_modules:
services:
  development:
    build:
      context: .
      dockerfile: ./Dockerfile.dev
    ports:
      - "3000:3000"
      - "24678:24678"
    volumes:
      - .:/src
      - node_modules:/src/node_modules
```

```yaml [vue]
services:
  production:
    platform: linux/amd64 # Add this code for Apple Silicon
    build:
      context: .
    ports:
      - "3001:3000"
```

:::

---

::tip
Exécuter l'environnement de développement
```sh
docker compose -f docker-compose.yml -f docker-compose.dev.yml up --build
```
::

---
title: FastAPI
description: Modern, high-performance web framework for building APIs with Python
navigation:
  icon: i-logos-fastapi-icon
seo:
  title: FastAPI - Complete Guide
  description: Comprehensive guide for developing APIs with FastAPI
---

::note
Official documentation

- [FastAPI](https://fastapi.tiangolo.com/)
- [Pydantic](https://docs.pydantic.dev/)
- [Uvicorn](https://www.uvicorn.org/)
  ::

## Prerequisites

```shell
# Create a development environment
python3 -m venv venv

# Activate the virtual environment
source venv/bin/activate

# Install FastAPI and Uvicorn
pip install "fastapi[all]"
```

::note
Deactivate the virtual environment

```shell
deactivate
```

::

## Quick start

### Create the `main.py` file

```python [main.py]
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```

### Start the server

```shell
uvicorn main:app --reload
```

::tip
**Access the docs**

- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`
  ::

## Routes and HTTP Methods

### Basic routes

```python [main.py]
from fastapi import FastAPI

app = FastAPI()

@app.get("/items")
async def get_items():
    return {"items": ["item1", "item2"]}

@app.post("/items")
async def create_item(name: str):
    return {"name": name, "id": 1}

@app.put("/items/{item_id}")
async def update_item(item_id: int, name: str):
    return {"id": item_id, "name": name}

@app.delete("/items/{item_id}")
async def delete_item(item_id: int):
    return {"message": f"Item {item_id} deleted"}
```

### Path parameters

```python
@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}

@app.get("/users/{user_id}/items/{item_id}")
async def read_user_item(user_id: int, item_id: str):
    return {"user_id": user_id, "item_id": item_id}
```

### Query parameters

```python
@app.get("/items")
async def read_items(skip: int = 0, limit: int = 10):
    return {"skip": skip, "limit": limit}

# Optional parameters
@app.get("/items/{item_id}")
async def read_item(item_id: str, q: str | None = None):
    if q:
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id}
```

## Pydantic Models

### Define models

```python [models.py]
from pydantic import BaseModel, Field, EmailStr
from datetime import datetime

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: str | None = Field(None, max_length=500)
    price: float = Field(..., gt=0)
    tax: float | None = None
    tags: list[str] = []

class User(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
    disabled: bool = False

    class Config:
        json_schema_extra = {
            "example": {
                "username": "johndoe",
                "email": "john@example.com",
                "full_name": "John Doe"
            }
        }
```

### Use models

```python [main.py]
from fastapi import FastAPI
from models import Item, User

app = FastAPI()

@app.post("/items")
async def create_item(item: Item):
    item_dict = item.model_dump()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.model_dump()}
```

## Error handling

```python [main.py]
from fastapi import FastAPI, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

items_db = {"foo": {"name": "Foo", "price": 50.2}}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )
    return items_db[item_id]

# Custom validation error handler
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()}
    )
```

## Dependencies

```python [dependencies.py]
from fastapi import Header, HTTPException

async def verify_token(x_token: str = Header()):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="Invalid token")

async def verify_key(x_key: str = Header()):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="Invalid key")
    return x_key
```

```python [main.py]
from fastapi import FastAPI, Depends
from dependencies import verify_token, verify_key

app = FastAPI()

@app.get("/items", dependencies=[Depends(verify_token)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

@app.get("/users")
async def read_users(key: str = Depends(verify_key)):
    return [{"username": "Rick"}, {"username": "Morty"}]
```

## Database

### SQLAlchemy setup

```python [database.py]
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### SQLAlchemy models

```python [models.py]
from sqlalchemy import Boolean, Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
```

### Usage

```python [main.py]
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from database import get_db
import models

app = FastAPI()

@app.post("/users")
def create_user(username: str, email: str, db: Session = Depends(get_db)):
    db_user = models.User(username=username, email=email)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get("/users/{user_id}")
def read_user(user_id: int, db: Session = Depends(get_db)):
    return db.query(models.User).filter(models.User.id == user_id).first()
```

## Middleware

```python [main.py]
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import time

app = FastAPI()

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Custom middleware
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

## Testing

```python [test_main.py]
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_create_item():
    response = client.post(
        "/items",
        json={"name": "Test", "price": 10.5}
    )
    assert response.status_code == 200
    assert response.json()["name"] == "Test"
```

```shell
# Install pytest
pip install pytest

# Run tests
pytest
```

## Dependency management

::tip
**requirements.txt file**

```shell
# Generate the file
pip freeze > requirements.txt

# Install from the file
pip install -r requirements.txt
```

::

```text [requirements.txt]
fastapi[all]==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.0
sqlalchemy==2.0.25
pytest==7.4.4
```

## Automate startup

### Startup script

```shell [start.sh]
#!/bin/bash

# Activate the virtual environment
source venv/bin/activate

# Start the server
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

```shell
# Make the script executable
chmod +x start.sh

# Run the project
./start.sh
```

## Deployment

### Docker

```dockerfile [Dockerfile]
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml [docker-compose.yml]
version: "3.8"

services:
  web:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/dbname
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=dbname
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### Production with Gunicorn

```shell
# Install Gunicorn
pip install gunicorn

# Start with Gunicorn
gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

## Best practices

::list{type="success"}

- Use Pydantic models for validation
- Document endpoints with descriptions
- Implement consistent error handling
- Use dependencies for reusable logic
- Write tests for every endpoint
- Version the API (`/api/v1/...`)
- Configure CORS properly
- Use environment variables for configuration
  ::

## Resources

::list{type="info"}

- [FastAPI documentation](https://fastapi.tiangolo.com/)
- [Official tutorial](https://fastapi.tiangolo.com/tutorial/)
- [Pydantic](https://docs.pydantic.dev/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [Awesome FastAPI](https://github.com/mjhea0/awesome-fastapi)
  ::

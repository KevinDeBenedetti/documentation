---
title: Nuxt
description: Text, headings and standard markdown formatting.
navigation:
  icon: i-devicon:nuxt
---

Nuxt is an open-source web framework based on Vue.js that enables building performant, SEO-friendly web applications. It provides server-side rendering (SSR), static site generation (SSG), and much more.

## Why choose Nuxt instead of Vue?

### When to use Nuxt

✅ **Use Nuxt if you need:**

- **SEO optimization**: Marketing sites, blogs, e-commerce
- **Performance**: Fast initial load with SSR or SSG
- **Automatic routing**: File-based pages
- **Server-Side Rendering**: Pre-rendered content on the server
- **Static Site Generation**: Fully static and ultra-fast sites
- **API routes**: Backend integrated directly within your project
- **Zero-config features**: Many features ready out of the box

### When to use Vue only

✅ **Use Vue if you build:**

- **SPAs (Single Page Applications)**: Dashboards, internal apps
- **Apps requiring full flexibility**: Custom configuration
- **Projects with specific architecture needs**
- **Applications not requiring SEO**: Internal tools, back-office
- **Rapid prototypes**: Simple projects without complex infra

### Vue vs Nuxt comparison

| Criteria                | Vue                 | Nuxt                          |
| ----------------------- | ------------------- | ----------------------------- |
| **Routing**             | Manual (Vue Router) | Automatic (file-based)        |
| **SEO**                 | Limited (CSR)       | Excellent (SSR/SSG)           |
| **Initial performance** | Slower (CSR)        | Faster (SSR/SSG)              |
| **Configuration**       | Manual              | Convention over configuration |
| **Backend**             | Separate            | Built-in API routes           |
| **Complexity**          | Simpler             | More concepts                 |
| **Deployment**          | Classic SPA         | Requires Node.js or static    |

## Installing Nuxt 3

```bash
npx nuxi@latest init my-app
cd my-app
npm install
npm run dev
```

## Automatic routing

### Pages and routes

Nuxt generates routes automatically based on the `pages/` folder structure.

```
pages/
├── index.vue           → /
├── about.vue           → /about
├── users/
│   ├── index.vue       → /users
│   ├── [id].vue        → /users/:id
│   └── profile.vue     → /users/profile
└── blog/
    └── [slug].vue      → /blog/:slug
```

### Dynamic page

```vue
<!-- filepath: pages/users/[id].vue -->
<script setup lang="ts">
const route = useRoute();
const userId = route.params.id;

const { data: user } = await useFetch(`/api/users/${userId}`);
</script>

<template>
  <div>
    <h1>Profile of {{ user?.name }}</h1>
  </div>
</template>
```

### Route with query parameters

```vue
<!-- filepath: pages/search.vue -->
<script setup lang="ts">
const route = useRoute();
const query = computed(() => route.query.q as string);

// Watch for query changes
watch(query, (newQuery) => {
  console.log("New search:", newQuery);
});
</script>
```

### Catch-all route

```vue
<!-- filepath: pages/[...slug].vue -->
<script setup lang="ts">
const route = useRoute();
const slug = route.params.slug; // ['path', 'to', 'page']
</script>
```

## Navigation

### NuxtLink

```vue
<template>
  <!-- Simple navigation -->
  <NuxtLink to="/about">About</NuxtLink>

  <!-- Navigation with parameters -->
  <NuxtLink :to="`/users/${user.id}`">Profile</NuxtLink>

  <!-- Navigation with object -->
  <NuxtLink :to="{ name: 'users-id', params: { id: 1 } }"> User 1 </NuxtLink>

  <!-- External link -->
  <NuxtLink to="https://example.com" external> External site </NuxtLink>

  <!-- Disable prefetch -->
  <NuxtLink to="/heavy-page" :prefetch="false"> Heavy page </NuxtLink>
</template>
```

### Programmatic navigation

```vue
<script setup lang="ts">
const router = useRouter();

function goToUser(id: number) {
  router.push(`/users/${id}`);
}

function goBack() {
  router.back();
}

async function navigateWithRedirect() {
  // Server-side redirect
  await navigateTo("/dashboard", { redirectCode: 301 });
}
</script>
```

## Layouts

### Default layout

```vue
<!-- filepath: layouts/default.vue -->
<template>
  <div>
    <header>
      <nav>
        <NuxtLink to="/">Home</NuxtLink>
        <NuxtLink to="/about">About</NuxtLink>
      </nav>
    </header>

    <main>
      <slot />
    </main>

    <footer>
      <p>&copy; 2024 My Site</p>
    </footer>
  </div>
</template>
```

### Custom layout

```vue
<!-- filepath: layouts/admin.vue -->
<template>
  <div class="admin-layout">
    <aside class="sidebar">
      <!-- Admin sidebar -->
    </aside>
    <main>
      <slot />
    </main>
  </div>
</template>
```

### Using layouts in pages

```vue
<!-- filepath: pages/admin/dashboard.vue -->
<script setup lang="ts">
definePageMeta({
  layout: "admin",
  middleware: "auth",
});
</script>

<template>
  <div>
    <h1>Admin Dashboard</h1>
  </div>
</template>
```

## Nuxt Composables

### useFetch — Data fetching

```vue
<script setup lang="ts">
interface User {
  id: number;
  name: string;
  email: string;
}

// Simple fetch
const { data: users, pending, error, refresh } = await useFetch<User[]>("/api/users");

// With options
const { data: user } = await useFetch<User>(`/api/users/${route.params.id}`, {
  key: `user-${route.params.id}`, // Unique cache key
  lazy: true, // Does not block navigation
  server: true, // Execute on server
  watch: [() => route.params.id], // Re-fetch when ID changes
  transform: (data) => {
    // Transform the data
    return { ...data, fullName: `${data.name}` };
  },
  onRequest({ request, options }) {
    // Interceptor before the request
  },
  onResponse({ response }) {
    // Interceptor after the response
  },
});
</script>

<template>
  <div v-if="pending">Loading...</div>
  <div v-else-if="error">Error: {{ error.message }}</div>
  <div v-else>
    <div v-for="user in users" :key="user.id">
      {{ user.name }}
    </div>
    <button @click="refresh()">Refresh</button>
  </div>
</template>
```

### useAsyncData — Custom data fetching

```vue
<script setup lang="ts">
// For complex or non-HTTP requests
const { data, pending } = await useAsyncData(
  "custom-data",
  async () => {
    // Custom logic
    const response = await $fetch("/api/data");
    const processed = processData(response);
    return processed;
  },
  {
    lazy: true,
    server: false, // Client-side only
  },
);
</script>
```

### useState — Shared state

```typescript
// composables/useCounter.ts
export const useCounter = () => {
  // Shared state between components
  const count = useState("counter", () => 0);

  function increment() {
    count.value++;
  }

  return { count, increment };
};
```

```vue
<!-- Use anywhere -->
<script setup lang="ts">
const { count, increment } = useCounter();
// The same state is shared everywhere
</script>
```

### useHead — Meta tags

```vue
<script setup lang="ts">
useHead({
  title: "My Page Title",
  meta: [
    { name: "description", content: "My page description" },
    { property: "og:title", content: "Open Graph title" },
    { property: "og:image", content: "/image.jpg" },
  ],
  link: [{ rel: "canonical", href: "https://mysite.com/page" }],
});

// Dynamic usage
const { data: article } = await useFetch("/api/article/1");

useHead({
  title: () => article.value?.title,
  meta: [{ name: "description", content: () => article.value?.description }],
});
</script>
```

### useCookie — Cookie management

```typescript
export const useAuth = () => {
  const token = useCookie("auth-token", {
    maxAge: 60 * 60 * 24 * 7, // 7 days
    secure: true,
    httpOnly: true,
    sameSite: "strict",
  });

  function setToken(newToken: string) {
    token.value = newToken;
  }

  function clearToken() {
    token.value = null;
  }

  return { token, setToken, clearToken };
};
```

## Middleware

### Route middleware

```typescript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { token } = useAuth();

  if (!token.value) {
    return navigateTo("/login");
  }
});
```

```vue
<!-- Use in a page -->
<script setup lang="ts">
definePageMeta({
  middleware: "auth",
});
</script>
```

### Global middleware

```typescript
// middleware/analytics.global.ts
export default defineNuxtRouteMiddleware((to, from) => {
  // Executed on every navigation
  console.log("Navigating to:", to.path);
});
```

### Inline middleware

```vue
<script setup lang="ts">
definePageMeta({
  middleware: [
    "auth",
    function (to, from) {
      // Inline middleware
      if (!hasPermission()) {
        return abortNavigation("Access denied");
      }
    },
  ],
});
</script>
```

## Server API routes

### Simple API route

```typescript
// server/api/hello.ts
export default defineEventHandler((event) => {
  return {
    message: "Hello World!",
  };
});
```

### Route with parameters

```typescript
// server/api/users/[id].ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");

  // Fetch user
  const user = await prisma.user.findUnique({
    where: { id: parseInt(id!) },
  });

  if (!user) {
    throw createError({
      statusCode: 404,
      message: "User not found",
    });
  }

  return user;
});
```

### POST route with validation

```typescript
// server/api/users/index.post.ts
import { z } from "zod";

const createUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(8),
});

export default defineEventHandler(async (event) => {
  const body = await readBody(event);

  // Validation
  const validatedData = createUserSchema.parse(body);

  // Create user
  const user = await prisma.user.create({
    data: validatedData,
  });

  return user;
});
```

### Server middleware

```typescript
// server/middleware/auth.ts
export default defineEventHandler(async (event) => {
  const token = getCookie(event, "auth-token");

  if (event.path.startsWith("/api/admin") && !token) {
    throw createError({
      statusCode: 401,
      message: "Not authenticated",
    });
  }
});
```

## Plugins

### Simple plugin

```typescript
// plugins/my-plugin.ts
export default defineNuxtPlugin((nuxtApp) => {
  // Global injection
  return {
    provide: {
      hello: (name: string) => `Hello ${name}!`,
    },
  };
});
```

```vue
<!-- Usage -->
<script setup lang="ts">
const { $hello } = useNuxtApp();
console.log($hello("World")); // "Hello World!"
</script>
```

### Plugin with dependency

```typescript
// plugins/axios.ts
import axios from "axios";

export default defineNuxtPlugin((nuxtApp) => {
  const api = axios.create({
    baseURL: "/api",
  });

  // Request interceptor
  api.interceptors.request.use((config) => {
    const token = useCookie("auth-token");
    if (token.value) {
      config.headers.Authorization = `Bearer ${token.value}`;
    }
    return config;
  });

  return {
    provide: {
      api,
    },
  };
});
```

## Nuxt configuration

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // Rendering mode
  ssr: true, // or false for SPA mode

  // Global metadata
  app: {
    head: {
      title: "My Application",
      meta: [
        { charset: "utf-8" },
        { name: "viewport", content: "width=device-width, initial-scale=1" },
      ],
    },
  },

  // Public runtime config
  runtimeConfig: {
    // Private (server only)
    apiSecret: process.env.API_SECRET,

    // Public (client + server)
    public: {
      apiBase: process.env.API_BASE_URL || "http://localhost:3000",
    },
  },

  // Auto-imports
  imports: {
    dirs: ["composables/**", "utils/**"],
  },

  // TypeScript
  typescript: {
    strict: true,
    typeCheck: true,
  },

  // Modules
  modules: ["@nuxt/content", "@nuxtjs/tailwindcss", "@pinia/nuxt"],

  // Router
  router: {
    options: {
      strict: true,
    },
  },

  // Optimization
  nitro: {
    compressPublicAssets: true,
    prerender: {
      crawlLinks: true,
      routes: ["/sitemap.xml"],
    },
  },
});
```

## Nuxt best practices

### 1. Prefer useFetch over $fetch for page data

```vue
<script setup lang="ts">
// ✅ Good: SSR-friendly, automatic caching
const { data } = await useFetch("/api/data");

// ❌ Avoid in setup blocking code: no cache, no SSR
const data = await $fetch("/api/data");
</script>
```

### 2. Use keys for cache

```vue
<script setup lang="ts">
const route = useRoute();

// ✅ Good: unique cache per ID
const { data } = await useFetch(`/api/users/${route.params.id}`, {
  key: `user-${route.params.id}`,
});

// ❌ Without key, the cache might be shared incorrectly
</script>
```

### 3. Prefer native composables

```typescript
// ✅ Good: use Nuxt composables
export const useUser = () => {
  const user = useState("user", () => null);

  async function fetchUser() {
    const { data } = await useFetch("/api/user");
    user.value = data.value;
  }

  return { user, fetchUser };
};

// ❌ Avoid: manual state without SSR
import { ref } from "vue";
export const useUser = () => {
  const user = ref(null); // Not shared between server/client
  return { user };
};
```

### 4. Optimize images

```vue
<template>
  <!-- ✅ Use NuxtImg for optimization -->
  <NuxtImg src="/image.jpg" width="300" height="200" loading="lazy" format="webp" />

  <!-- ❌ Unoptimized image -->
  <img src="/image.jpg" alt="" />
</template>
```

### 5. Handle errors properly

```vue
<script setup lang="ts">
const { data, error } = await useFetch("/api/data");

if (error.value) {
  throw createError({
    statusCode: error.value.statusCode,
    message: "Unable to load data",
    fatal: true, // Show error page
  });
}
</script>
```

### 6. Use custom error pages

```vue
<!-- filepath: error.vue -->
<script setup lang="ts">
const props = defineProps<{
  error: {
    statusCode: number;
    message: string;
  };
}>();

function handleError() {
  clearError({ redirect: "/" });
}
</script>

<template>
  <div>
    <h1>{{ error.statusCode }}</h1>
    <p>{{ error.message }}</p>
    <button @click="handleError">Go back home</button>
  </div>
</template>
```

## SEO modules

::info
[Nuxt Module](https://nuxt.com/modules/seo)<br>
[SEO](https://nuxtseo.com/)
::

:::card-group

::card

---

title: '@nuxtjs/sitemap'
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/sitemap
target: \_blank

---

Automatically generates an XML sitemap to help search engines index your pages.
::

::card

---

title: '@nuxtjs/robots'
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/robots
target: \_blank

---

Creates a robots.txt file to manage crawler access.
::

::card

---

title: nuxt-schema-org
icon: i-simple-icons-github
to: https://github.com/harlan-zw/nuxt-schema-org
target: \_blank

---

Easily integrates JSON-LD schema tags to enhance search results.
::

::card

---

title: nuxt-seo-experiments
icon: i-simple-icons-github
to: https://github.com/harlan-zw/nuxt-seo
target: \_blank

---

Allows you to experiment with various SEO optimizations.
::

::card

---

title: nuxt-og-image
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/og-image
target: \_blank

---

Generates images for social media previews.
::

::card

---

title: nuxt-link-checker
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/link-checker
target: \_blank

---

Checks link validity to avoid 404 errors.
::

:::

### Installing SEO modules

```bash
npx nuxi@latest module add seo
```

### SEO configuration

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ["@nuxtjs/seo"],

  site: {
    url: "https://mysite.com",
    name: "My Site",
    description: "Site description",
    defaultLocale: "en",
  },

  sitemap: {
    strictNuxtContentPaths: true,
  },

  robots: {
    allow: "/",
    disallow: ["/admin", "/api"],
  },
});
```

## Deployment

### SSR mode (Node.js server)

```bash
npm run build
node .output/server/index.mjs
```

### Static mode (SSG)

```bash
npx nuxi generate
# Deploy the .output/public folder
```

### Recommended platforms

- **Vercel**: SSR and SSG, automated deployment
- **Netlify**: Primarily SSG
- **Cloudflare Pages**: SSG and Workers for SSR
- **Railway**: SSR with Node.js
- **DigitalOcean**: SSR with Docker
